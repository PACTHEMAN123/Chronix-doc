#import "../template.typ": img

= 物理平台适配

我们在适配两个架构的物理板的过程中，遇到了一些问题，希望在此提出解决方案以供后人参考：

== VisionFive2 星光板

- 需要注意 qemu 与物理板的差别
- 在进入的内核的初始化阶段，可以使用 OpenSBI 自带的串口函数输出调试信息，避免因为串口驱动实现的 bug，导致无法输出任何调试信息。
- 内核初始化时需要将 bss 段清 0
- 注意 VisionFive2 的默认的启动核是 hart1 而非 qemu 的 hart0，需要检查内核中是否存在对于启动核的假设。
- 提前进行中断/异常的入口的设置。若访存错误发生在中断/异常初始化之前，可能会导致跳转到不可知位置，并且得不到任何信息。

=== PTE A/D 位管理

我们在移植时，在内核初始化时的驱动访存中出现了问题。通过查阅资料，我们发现RISC-V 在 A/D 位的管理上，为硬件实现者提供了两种不同的策略：
- 当 MMU (内存管理单元) 在地址翻译过程中，遇到一个有效的 (`V=1`) PTE，但其 `A` 位为 0 时，MMU 会在硬件层面自动、原子地将该 PTE 的 `A` 位设置为 1，然后继续完成内存访问。整个过程对操作系统软件完全透明，不会触发任何异常。对于写操作和 `D` 位也是同理。
- 当 MMU 遇到一个有效的 (`V=1`) PTE，但其 `A` 位为 0 时，它不会自己修改 PTE。相反，它会立即停止当前的内存访问，并触发一个页错误异常。这种异常被称为“访问错误 (Access Fault)”，以区别于页面不存在 (`V=0`) 导致的“缺页 (Page Fault)”。

我们的 OS 的页错误处理程序只处理了 `V=0` 的情况（真正的缺页），因为它从未有机会遇到由 `A=0` 或 `D=0` 触发的异常。当这样的代码在 VisionFive 2 上运行时，硬件忠实地触发了访问错误，但操作系统却错误地将其当作缺页来处理，从而导致系统崩溃。



